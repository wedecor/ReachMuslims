import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/lead.dart';
import '../../domain/models/user.dart';
import '../../domain/repositories/lead_repository.dart';
import '../../core/errors/failures.dart';
import 'lead_list_provider.dart';

class LeadCreateState {
  final String name;
  final String phone;
  final String? location;
  final UserRegion region;
  final LeadStatus status;
  final String? assignedTo;
  final bool isLoading;
  final Failure? error;

  const LeadCreateState({
    this.name = '',
    this.phone = '',
    this.location,
    this.region = UserRegion.india,
    this.status = LeadStatus.newLead,
    this.assignedTo,
    this.isLoading = false,
    this.error,
  });

  LeadCreateState copyWith({
    String? name,
    String? phone,
    String? location,
    UserRegion? region,
    LeadStatus? status,
    String? assignedTo,
    bool? isLoading,
    Failure? error,
    bool clearLocation = false,
    bool clearAssignedTo = false,
    bool clearError = false,
  }) {
    return LeadCreateState(
      name: name ?? this.name,
      phone: phone ?? this.phone,
      location: clearLocation ? null : (location ?? this.location),
      region: region ?? this.region,
      status: status ?? this.status,
      assignedTo: clearAssignedTo ? null : (assignedTo ?? this.assignedTo),
      isLoading: isLoading ?? this.isLoading,
      error: clearError ? null : (error ?? this.error),
    );
  }

  Map<String, String?> get validationErrors {
    final errors = <String, String?>{};
    if (name.trim().isEmpty) {
      errors['name'] = 'Name is required';
    }
    if (phone.trim().isEmpty) {
      errors['phone'] = 'Phone is required';
    } else if (!_isValidPhone(phone)) {
      errors['phone'] = 'Please enter a valid phone number';
    }
    return errors;
  }

  bool get isValid => validationErrors.isEmpty;

  bool _isValidPhone(String phone) {
    // Basic phone validation - at least 10 digits
    final digitsOnly = phone.replaceAll(RegExp(r'[^\d]'), '');
    return digitsOnly.length >= 10;
  }
}

class LeadCreateNotifier extends StateNotifier<LeadCreateState> {
  final LeadRepository _leadRepository;

  LeadCreateNotifier(this._leadRepository) : super(const LeadCreateState());

  void setName(String name) {
    state = state.copyWith(name: name, clearError: true);
  }

  void setPhone(String phone) {
    state = state.copyWith(phone: phone, clearError: true);
  }

  void setLocation(String? location) {
    state = state.copyWith(location: location, clearLocation: location == null || location.isEmpty);
  }

  void setRegion(UserRegion region) {
    state = state.copyWith(region: region);
  }

  void setStatus(LeadStatus status) {
    state = state.copyWith(status: status);
  }

  void setAssignedTo(String? assignedTo) {
    state = state.copyWith(assignedTo: assignedTo, clearAssignedTo: assignedTo == null);
  }

  void reset() {
    state = const LeadCreateState();
  }

  Future<Lead?> createLead() async {
    if (!state.isValid) {
      state = state.copyWith(
        error: const AuthFailure('Please fix validation errors'),
      );
      return null;
    }

    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final now = DateTime.now();
      final lead = Lead(
        id: '', // Will be generated by Firestore
        name: state.name.trim(),
        phone: state.phone.trim(),
        location: state.location?.trim().isEmpty == true ? null : state.location?.trim(),
        region: state.region,
        status: state.status,
        assignedTo: state.assignedTo?.isEmpty == true ? null : state.assignedTo,
        createdAt: now,
        updatedAt: now,
      );

      final createdLead = await _leadRepository.createLead(lead);
      state = state.copyWith(isLoading: false);
      return createdLead;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e is Failure ? e : FirestoreFailure('Failed to create lead: ${e.toString()}'),
      );
      return null;
    }
  }
}

final leadCreateProvider = StateNotifierProvider<LeadCreateNotifier, LeadCreateState>((ref) {
  final leadRepository = ref.watch(leadRepositoryProvider);
  return LeadCreateNotifier(leadRepository);
});

